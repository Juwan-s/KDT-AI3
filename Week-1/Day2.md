<h1> Day2 </h1>
<hr>
<h2> Stack </h2>
스택은 마치 접시를 쌓았다가 다시 꺼내는 것처럼, 추가는 순서대로 하되 뺄 때는 가장 최근에 넣은 것부터 빼는 
자료구조이다.<br>
즉, 자료 (data element)를 보관할 수 있는 선형 구조 ( 후입 선출 )

<br><br>

- size(): 현재 스택에 들어 있는 데이터 원소의 수를 구함
- isEmpty(): 현재 스택이 비어 있는지를 판단 (size() == 0?)
- push(x): 데이터 원소 x 를 스택에 추가
- pop(): 스택에 가장 나중에 저장된 데이터 원소를 제거 (또한, 반환)
- peek(): 스택에 가장 나중에 저장된 데이터 원소를 참조 (반환), 그러나 제거하지는 않음

<br>
<h3> 스택에서 발생하는 오류 </h3>
- 스택 언더플로우 : 비어있는 스택에서 데이터 원소를 꺼내려 할 때
- 스택 오버플로우 : 꽉 찬 스택에 데이터 원소를 넣으려 할 때

<br>

<h2> 스택의 응용 - 수식 후위 표기법 </h2>

우리가 주로 쓰는 표기법은 중위 표기법임. 그러나 후위 표기법을 이용하면 괄호를 쓰지 않고도 연산의 우선순위를 수식에 표현할 수 있다.

<br> <h3>수식의 계산을 행하는 알고리즘</h3>

- 수식을 왼쪽부터 시작해서 오른쪽으로 차례대로 읽어들이면서
- 피연산자가 나타나면, 스택에 넣어 둔다.
- 연산자가 나타나면, 스택에 들어 있는 피연산자를 두 개 꺼내어 연산을 적용하고, 그 결과를 다시 스택에 넣어 둔다.

<br>
<h2> 큐 (Queues)</h2>

큐 또한 자료를 보관할 수 있는 선형 구조.

연산
- size() : 큐의 사이즈 반환
- isEmpty() : 큐가 비어있는 지 검사
- enqueue() : 큐에 데이터 추가
- dequeue() : 큐의 원소 제거 ( 유일하게 O(n) 시간이 걸림 )
- peek() : 큐의 맨 앞 원소 리턴 ( 제거하지 않음 )

<br>
<h2> Circular Queue </h2>

큐의 활용 : 자료를 생성하는 작업과 그 자료를 이용하는 작업이 비동기적으로 일어나는 경우, 자료를 처리하여 새로운 자료를 생성하고, 나중에 그 자료를 또 처리해야하는 작업의 경우
<br>
환형 큐 : 정해진 개수의 저장 공간을 빙 돌려가며 이용한다.
<br> 환형 큐 연산의 정의
- size() : 현재 큐에 들어있는 데이터 원소의 수를 구함
- isEmpty() : 현재 큐가 비어있는 지 판단
- isFull() : 큐에 데이터 원소가 꽉 차 있는지를 판단
- enqueue(x) : 데이터 원소 x를 큐에 추가
- dequeue() : 큐의 맨 앞에 저장된 데이터 원소를 제거 ( + 반환)
- peek() : 큐의 맨 앞에 저장된 데이터 원소를 반환( 제거 안함 )
<br> 특히 front와 rear를 적절히 계산해서 배열을 환형으로 재활용해야한다.


<br>
<h2> 우선순위 Queue </h2>

우선 순위 큐 : 큐가 FIFO를 따르지 않고 원소들의 우선순위에 따라 큐에서 빠져나오는 방식, 양방향 연결 리스트를 선택하여 우선순위 큐를 구현




